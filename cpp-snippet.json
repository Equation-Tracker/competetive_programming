{
  // Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and
  // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the
  // same ids are connected.
  // Example:
  // "Print to console": {
  // 	"prefix": "log",
  // 	"body": [
  // 		"console.log('$1');",
  // 		"$2"
  // 	],
  // 	"description": "Log output to console"
  // }
  "Standard C++ Syntax": {
    "prefix": "cpps",
    "body": [
      "#include <iostream>",
      "",
      "int main() {",
      "\t$1",
      "\treturn 0;",
      "}"
    ],
    "description": "Basic C++ code structure"
  },
  "Sign": {
    "prefix": "signature",
    "body": [
      "/*==============================================*\\",
      "|  Author   : Equation Tracker                    |",
      "|  Handle   : Equation_Tracker                    |",
      "|  Mission  : Breach the Limits âš¡                 |",
      "|  Realm    : Competitive Programming             |",
      "|  Status   : [ ACTIVE ]                          |",
      "\\*==============================================*/",
      "",
    ],
    "description": "Add signature template",
  },
  "Competetive Programming template": {
    "prefix": "fcpp",
    "body": [
      "/*==============================================*\\",
      "|  Author   : Equation Tracker                    |",
      "|  Handle   : Equation_Tracker                    |",
      "|  Mission  : Breach the Limits                   |",
      "|  Realm    : Competitive Programming             |",
      "|  Status   : [ ACTIVE ]                          |",
      "\\*==============================================*/",
      "",
      "#pragma GCC optimize(\"Ofast\", \"O3\")",
      "#include <ext/pb_ds/assoc_container.hpp>",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "#include <bits/stdc++.h>",
      "#include <iostream>",
      "#include <chrono>",
      "using namespace std;",
      "using namespace __gnu_pbds;",
      "typedef long long ll;",
      "#define whole(v) v.begin(), v.end()",
      "#define arr_out(v) for (auto x: v) cout << x << \" \"; cout << \"\\n\";",
      "#define loop(x) for (long long i = 0; i < x; i++)",
      "struct custom_hash {",
      "\tstatic uint64_t splitmix64(uint64_t x);",
      "\tsize_t operator()(uint64_t x) const;",
      "};",
      "void totalSolution();",
      "void caseSolution();",
      "long long nCr(long long, long long);",
      "template <typename _Tp, typename Cm_fn = std::less<_Tp>>",
      "using ordered_set = __gnu_pbds::tree<_Tp, __gnu_pbds::null_type, Cm_fn, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;",
      "template <typename _Tp, typename _vTp, typename Cm_fn = std::less<_Tp>>",
      "using ordered_map = __gnu_pbds::tree<_Tp, _vTp, Cm_fn, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;",
      "template <typename _Tp>",
      "class Segment_Tree {",
      "private:",
      "\tstd::vector<_Tp> Tree, arr, lazy;",
      "\tbool one_based;",
      "\tvoid lazyUpdate(long long node, long long l, long long r) {",
      "\t\tif (lazy[node] != 0) {",
      "\t\t\tTree[node] += (r - l + 1) * lazy[node]; // <== CHANGE FOR max: Tree[node] += lazy[node];",
      "\t\t\tif (l != r) {",
      "\t\t\t\tlazy[2 * node] += lazy[node];",
      "\t\t\t\tlazy[2 * node + 1] += lazy[node];",
      "\t\t\t}",
      "\t\t\tlazy[node] = 0;",
      "\t\t}",
      "\t}",
      "\tvoid build(long long node, long long l, long long r) {",
      "\t\tif (l == r) {",
      "\t\t\tTree[node] = arr[l];",
      "\t\t\treturn;",
      "\t\t}",
      "\t\tlong long mid = (l + r) / 2;",
      "\t\tbuild(2 * node, l, mid);",
      "\t\tbuild(2 * node + 1, mid + 1, r);",
      "\t\tTree[node] = Tree[2 * node] + Tree[2 * node + 1]; // <== CHANGE FOR max: max(Tree[2 * node], Tree[2 * node + 1])",
      "\t}",
      "\t_Tp queryUtil(long long node, long long l, long long r, long long start, long long end) {",
      "\t\tlazyUpdate(node, l, r);",
      "\t\tif (end < l || r < start) return 0; // <== CHANGE FOR max: LLONG_MIN",
      "\t\tif (start <= l && r <= end) return Tree[node];",
      "\t\tlong long mid = (l + r) / 2;",
      "\t\t_Tp left = queryUtil(2 * node, l, mid, start, end);",
      "\t\t_Tp right = queryUtil(2 * node + 1, mid + 1, r, start, end);",
      "\t\treturn left + right; // <== CHANGE FOR max: max(left, right)",
      "\t}",
      "\tvoid updateUtil(long long node, long long index, long long value, long long l, long long r) {",
      "\t\tlazyUpdate(node, l, r);",
      "\t\tif (l == r) {",
      "\t\t\tarr[index] += value;",
      "\t\t\tTree[node] += value;",
      "\t\t\treturn;",
      "\t\t}",
      "\t\tlong long mid = (l + r) / 2;",
      "\t\tif (index <= mid) updateUtil(2 * node, index, value, l, mid);",
      "\t\telse updateUtil(2 * node + 1, index, value, mid + 1, r);",
      "\t\tTree[node] = Tree[2 * node] + Tree[2 * node + 1]; // <== CHANGE FOR max: max(Tree[2 * node], Tree[2 * node + 1])",
      "\t}",
      "\tvoid rangeUpdateUtil(long long node, long long l, long long r, long long value, long long start, long long end) {",
      "\t\tlazyUpdate(node, l, r);",
      "\t\tif (r < start || end < l) return;",
      "\t\tif (start <= l && r <= end) {",
      "\t\t\tTree[node] += value * (r - l + 1); // <== CHANGE FOR max: Tree[node] += value",
      "\t\t\tif (l != r) {",
      "\t\t\t\tlazy[2 * node] += value;",
      "\t\t\t\tlazy[2 * node + 1] += value;",
      "\t\t\t}",
      "\t\t\treturn;",
      "\t\t}",
      "\t\tlong long mid = (l + r) / 2;",
      "\t\trangeUpdateUtil(2 * node, l, mid, value, start, end);",
      "\t\trangeUpdateUtil(2 * node + 1, mid + 1, r, value, start, end);",
      "\t\tTree[node] = Tree[2 * node] + Tree[2 * node + 1]; // <== CHANGE FOR max: max(Tree[2 * node], Tree[2 * node + 1])",
      "\t}",
      "public:",
      "\t_Tp query(long long start, long long end) {",
      "\t\tif (one_based) return queryUtil(1, 1, arr.size() - 1, start, end);",
      "\t\treturn queryUtil(1, 0, arr.size() - 1, start, end);",
      "\t}",
      "\tvoid update(long long index, long long value) {",
      "\t\tif (one_based) updateUtil(1, index, value, 1, arr.size() - 1);",
      "\t\telse updateUtil(1, index, value, 0, arr.size() - 1);",
      "\t}",
      "\tvoid rangeUpdate(long long start, long long end, long long value) {",
      "\t\tif (one_based) rangeUpdateUtil(1, 1, arr.size() - 1, value, start, end);",
      "\t\telse rangeUpdateUtil(1, 0, arr.size() - 1, value, start, end);",
      "\t}",
      "\tSegment_Tree(std::vector<_Tp> &a, bool is_one_based = false) {",
      "\t\tone_based = is_one_based;",
      "\t\tarr = is_one_based ? vector<_Tp>(a.size() + 1) : a;",
      "\t\tif (is_one_based) for (long long i = 1; i < arr.size(); i++) arr[i] = a[i - 1];",
      "\t\tTree.resize(4 * arr.size(), 0); // <== CHANGE FOR max: LLONG_MIN",
      "\t\tlazy.resize(4 * arr.size());",
      "\t\tif (one_based) build(1, 1, arr.size() - 1);",
      "\t\telse build(1, 0, arr.size() - 1);",
      "\t}",
      "};",
      "vector<long long> primes{};",
      "void genPrimes(long long lim = 2.53e6);",
      "int main(int argc, char const *argv[]) {",
      "\tios_base::sync_with_stdio(false);",
      "\tcin.tie(NULL);",
      "\tcout.tie(NULL);",
      "\ttotal$1Solution();",
      "\treturn 0;",
      "}",
      "void caseSolution() {",
      "\tlong long n = 0, m = 0, k = 0, l = 0, sum = 0, t1 = 0, t2 = 0;",
      "\tstring s = \"\", t = \"\";",
      "\tcin >> ${2:n};",
      "\t$0",
      "}",
      "void totalSolution() {",
      "\tlong long T;",
      "\tcin >> T;",
      "\twhile (T-- > 0) caseSolution();",
      "}",
      "uint64_t custom_hash::splitmix64(uint64_t x) {",
      "\tx += 0x9e3779b97f4a7c15;",
      "\tx = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
      "\tx = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
      "\treturn x ^ (x >> 31);",
      "}",
      "size_t custom_hash::operator()(uint64_t x) const {",
      "\tstatic const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
      "\treturn splitmix64(x + FIXED_RANDOM);",
      "}",
      "void genPrimes(long long lim) {",
      "\tvector<bool> visited(lim, 0);",
      "\tfor (long long p = 2; p < lim; p++) {",
      "\t\tif (visited[p]) continue;",
      "\t\tfor (long long i = p * p; i < lim; i += p) visited[i] = 1;",
      "\t\tprimes.push_back(p);",
      "\t}",
      "}",
      "long long nCr(long long n, long long r) {",
      "\tif (r > n) return 0;",
      "\tif (r > n - r) r = n - r;",
      "\tunsigned long long result = 1;",
      "\tfor (int i = 0; i < r; ++i) {",
      "\t\tresult *= (n - i);",
      "\t\tresult /= (i + 1);",
      "\t}",
      "\treturn result;",
      "}",
    ],
    "description": "Basic C++ code structure"
  },
  "TestCase input and loop": {
    "prefix": "tci",
    "body": [
      "cin >> T;",
      "while (T-- > 0) {",
      "\tcin >> n;",
      "\tres = 0;",
      "\t$2",
      "\tlast:",
      "}"
    ],
    "description": "Testcase code"
  },
  "Array Input snippet": {
    "prefix": "arrin",
    "body": [
      "long long c = 0;",
      "while (c < ${2:n}) {",
      "\tcin >> ${3:nums}[c++];$4",
      "}",
      "$0"
    ],
    "description": "Array input"
  },
  "Include Header syntax": {
    "prefix": "inc",
    "body": [
      "#include <$1>"
    ],
    "description": "Quickly include header file."
  },
  "Shorthand for cout...endl": {
    "prefix": "cio",
    "body": [
      "std::cout << ${1:res} << \"\\n\";"
    ],
    "description": "Quickly use C++ standard output with new line."
  },
  "Shorthand for outputting Strings": {
    "prefix": "cis",
    "body": [
      "printf(\"%s\\n\", ${1:s}.c_str());"
    ],
    "description": "Quickly use C++ standard output with new line."
  }
}
