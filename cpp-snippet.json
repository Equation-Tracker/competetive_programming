{
  "Standard C++ Syntax": {
    "prefix": "cpps",
    "body": [
      "#include <iostream>",
      "",
      "int main() {",
      "\t$1",
      "\treturn 0;",
      "}"
    ],
    "description": "Basic C++ code structure"
  },
  "Sign": {
    "prefix": "signature",
    "body": [
      "/*==============================================*\\",
      "|  Author   : Equation Tracker                    |",
      "|  Handle   : Equation_Tracker                    |",
      "|  Mission  : Breach the Limits                   |",
      "|  Realm    : Competitive Programming             |",
      "|  Status   : [ ACTIVE ]                          |",
      "\\*==============================================*/",
      "",
    ],
    "description": "Add signature template",
  },
  "Competetive Programming template": {
    "prefix": "fcpp",
    "body": [
      "/*==============================================*\\",
      "|  Author   : Equation Tracker                    |",
      "|  Handle   : Equation_Tracker                    |",
      "|  Mission  : Breach the Limits                   |",
      "|  Realm    : Competitive Programming             |",
      "|  Status   : [ ACTIVE ]                          |",
      "\\*==============================================*/",
      "",
      "#if defined(__GNUC__) && !defined(DEBUG)",
      "\t#pragma GCC optimize(\"Ofast\", \"O3\")",
      "#endif",
      "#include <ext/pb_ds/assoc_container.hpp>",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "#include <bits/stdc++.h>",
      "#include <iostream>",
      "#include <chrono>",
      "using namespace std;",
      "using namespace __gnu_pbds;",
      "typedef long long ll;",
      "#define whole(v) v.begin(), v.end()",
      "#define arr_out(v) for (auto x: v) cout << x << \" \"; cout << \"\\n\";",
      "#define loop(x) for (long long i = 0; i < x; i++)",
      "struct custom_hash {",
      "\tstatic uint64_t splitmix64(uint64_t x);",
      "\tsize_t operator()(uint64_t x) const;",
      "};",
      "void totalSolution();",
      "void caseSolution();",
      "long long nCr(long long, long long);",
      "template <typename _Tp, typename Cm_fn = std::less<_Tp>>",
      "using ordered_set = __gnu_pbds::tree<_Tp, __gnu_pbds::null_type, Cm_fn, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;",
      "template <typename _Tp, typename _vTp, typename Cm_fn = std::less<_Tp>>",
      "using ordered_map = __gnu_pbds::tree<_Tp, _vTp, Cm_fn, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;",
      "template <typename _Tp>",
      "class Graph {",
      "private:",
      "\tstd::map<_Tp, std::set<_Tp>> g;",
      "\tstd::set<std::pair<_Tp, _Tp>> edges;",
      "\tvoid dfsUtil(const _Tp& node, std::set<_Tp>& visited, const std::optional<_Tp>& parent) {",
      "\t\tif (visited.find(node) != visited.end()) return;",
      "\t\tvisited.insert(node);",
      "\t\t// <== Do something",
      "\t\tfor (const auto& n : g[node]) {",
      "\t\t\tif (parent && n == *parent) continue;",
      "\t\t\tdfsUtil(n, visited, node);",
      "\t\t}",
      "\t}",
      "\tbool dfsCycleDirected(const _Tp& node, std::set<_Tp>& visited, std::set<_Tp>& recStack) {",
      "\t\tif (recStack.find(node) != recStack.end()) return true;",
      "\t\tif (visited.find(node) != visited.end()) return false;",
      "\t\tvisited.insert(node);",
      "\t\trecStack.insert(node);",
      "\t\tfor (const auto& n : g[node]) {",
      "\t\t\tif (dfsCycleDirected(n, visited, recStack)) return true;",
      "\t\t}",
      "\t\trecStack.erase(node);",
      "\t\treturn false;",
      "\t}",
      "\tbool dfsCycleUndirected(const _Tp& node, std::set<_Tp>& visited, const std::optional<_Tp>& parent) {",
      "\t\tif (visited.find(node) != visited.end()) return false;",
      "\t\tvisited.insert(node);",
      "\t\tfor (const auto& n : g[node]) {",
      "\t\t\tif (parent && n == *parent) continue;",
      "\t\t\tif (visited.find(n) != visited.end()) return true;",
      "\t\t\tif (dfsCycleUndirected(n, visited, node)) return true;",
      "\t\t}",
      "\t\treturn false;",
      "\t}",
      "public:",
      "\tvoid addEdge(const _Tp& from, const _Tp& to, bool directed = true) {",
      "\t\tif (!g.count(from)) g[from] = {};",
      "\t\tif (!g.count(to)) g[to] = {};",
      "\t\tg[from].insert(to);",
      "\t\tif (!directed) g[to].insert(from);",
      "\t\tedges.insert({from, to});",
      "\t}",
      "\tbool hasNode(const _Tp& u) const { return g.find(u) != g.end(); }",
      "\tbool hasEdge(const _Tp& u, const _Tp& v) const { auto it = g.find(u); return it != g.end() && it->second.count(v); }",
      "\tstd::vector<_Tp> neighbors(const _Tp& u) const { if (!hasNode(u)) return {}; return std::vector<_Tp>(g.at(u).begin(), g.at(u).end()); }",
      "\tlong long size() const { return static_cast<long long>(g.size()); }",
      "\tlong long edgeCount() const { return static_cast<long long>(edges.size()); }",
      "\tlong long degree(const _Tp& u) const { if (!hasNode(u)) return 0; return static_cast<long long>(g.at(u).size()); }",
      "\tvoid removeEdge(const _Tp& u, const _Tp& v, bool directed = true) {",
      "\t\tif (hasNode(u)) g[u].erase(v);",
      "\t\tif (!directed && hasNode(v)) g[v].erase(u);",
      "\t\tedges.erase({u, v});",
      "\t}",
      "\tvoid removeNode(const _Tp& u) {",
      "\t\tif (!hasNode(u)) return;",
      "\t\tg.erase(u);",
      "\t\tstd::vector<std::pair<_Tp, _Tp>> toErase;",
      "\t\tfor (auto it = edges.begin(); it != edges.end(); ++it) {",
      "\t\t\tif (it->first == u || it->second == u) toErase.push_back(*it);",
      "\t\t}",
      "\t\tfor (auto& p : toErase) edges.erase(p);",
      "\t\tfor (auto& [node, ns] : g) ns.erase(u);",
      "\t}",
      "\tvoid clear() { g.clear(); edges.clear(); }",
      "\tbool isConnected(const _Tp& root) const {",
      "\t\tif (!hasNode(root)) return false;",
      "\t\tstd::set<_Tp> visited;",
      "\t\tconst_cast<Graph*>(this)->dfsUtil(root, visited, std::nullopt);",
      "\t\treturn visited.size() == g.size();",
      "\t}",
      "\tstd::set<_Tp> connectedComponents() const {",
      "\t\tstd::set<_Tp> seen;",
      "\t\tstd::set<_Tp> all;",
      "\t\tfor (const auto& [k, _v] : g) all.insert(k);",
      "\t\tfor (const auto& node : all) {",
      "\t\t\tif (seen.find(node) != seen.end()) continue;",
      "\t\t\tstd::queue<_Tp> q;",
      "\t\t\tq.push(node);",
      "\t\t\twhile (!q.empty()) {",
      "\t\t\t\tauto cur = q.front(); q.pop();",
      "\t\t\t\tif (seen.find(cur) != seen.end()) continue;",
      "\t\t\t\tseen.insert(cur);",
      "\t\t\t\tfor (const auto& n : g.at(cur)) if (seen.find(n) == seen.end()) q.push(n);",
      "\t\t\t}",
      "\t\t}",
      "\t\treturn seen;",
      "\t}",
      "\tbool hasPath(const _Tp& src, const _Tp& dest) const {",
      "\t\tif (!hasNode(src) || !hasNode(dest)) return false;",
      "\t\tstd::queue<_Tp> q; std::set<_Tp> vis;",
      "\t\tq.push(src); vis.insert(src);",
      "\t\twhile (!q.empty()) {",
      "\t\t\tauto u = q.front(); q.pop();",
      "\t\t\tif (u == dest) return true;",
      "\t\t\tfor (const auto& n : g.at(u)) if (vis.find(n) == vis.end()) { vis.insert(n); q.push(n); }",
      "\t\t}",
      "\t\treturn false;",
      "\t}",
      "\tstd::vector<_Tp> shortestPathUnweighted(const _Tp& src, const _Tp& dest) const {",
      "\t\tif (!hasNode(src) || !hasNode(dest)) return {};",
      "\t\tstd::queue<_Tp> q; std::map<_Tp, _Tp> parent; std::set<_Tp> vis;",
      "\t\tq.push(src); vis.insert(src); parent[src] = src;",
      "\t\twhile (!q.empty()) {",
      "\t\t\tauto u = q.front(); q.pop();",
      "\t\t\tif (u == dest) break;",
      "\t\t\tfor (const auto& n : g.at(u)) {",
      "\t\t\t\tif (vis.find(n) != vis.end()) continue;",
      "\t\t\t\tvis.insert(n); parent[n] = u; q.push(n);",
      "\t\t\t}",
      "\t\t}",
      "\t\tif (vis.find(dest) == vis.end()) return {};",
      "\t\tstd::vector<_Tp> path;",
      "\t\tfor (_Tp cur = dest;; cur = parent[cur]) {",
      "\t\t\tpath.push_back(cur);",
      "\t\t\tif (cur == parent[cur]) break;",
      "\t\t}",
      "\t\tstd::reverse(path.begin(), path.end());",
      "\t\treturn path;",
      "\t}",
      "\tbool hasCycle(bool directed) {",
      "\t\tstd::set<_Tp> visited;",
      "\t\tif (directed) {",
      "\t\t\tstd::set<_Tp> rec;",
      "\t\t\tfor (const auto& [node, _] : g) if (dfsCycleDirected(node, const_cast<std::set<_Tp>&>(visited), const_cast<std::set<_Tp>&>(rec))) return true;",
      "\t\t\treturn false;",
      "\t\t} else {",
      "\t\t\tstd::set<_Tp> vis2;",
      "\t\t\tfor (const auto& [node, _] : g) if (vis2.find(node) == vis2.end() && dfsCycleUndirected(node, vis2, std::nullopt)) return true;",
      "\t\t\treturn false;",
      "\t\t}",
      "\t}",
      "\tstd::vector<_Tp> topologicalSort() const {",
      "\t\tstd::map<_Tp, int> indeg;",
      "\t\tfor (const auto& [u, _] : g) indeg[u] = 0;",
      "\t\tfor (const auto& [u, ns] : g) for (const auto& v : ns) indeg[v]++;",
      "\t\tstd::queue<_Tp> q;",
      "\t\tfor (const auto& [k, v] : indeg) if (v == 0) q.push(k);",
      "\t\tstd::vector<_Tp> res;",
      "\t\twhile (!q.empty()) {",
      "\t\t\tauto u = q.front(); q.pop(); res.push_back(u);",
      "\t\t\tfor (const auto& v : g.at(u)) {",
      "\t\t\t\tindeg[v]--;",
      "\t\t\t\tif (indeg[v] == 0) q.push(v);",
      "\t\t\t}",
      "\t\t}",
      "\t\tif (res.size() != g.size()) return {};",
      "\t\treturn res;",
      "\t}",
      "\tbool isBipartite(const _Tp& start) const {",
      "\t\tif (!hasNode(start)) return false;",
      "\t\tstd::map<_Tp, int> color;",
      "\t\tstd::queue<_Tp> q;",
      "\t\tq.push(start); color[start] = 0;",
      "\t\twhile (!q.empty()) {",
      "\t\t\tauto u = q.front(); q.pop();",
      "\t\t\tfor (const auto& v : g.at(u)) {",
      "\t\t\t\tif (!color.count(v)) { color[v] = color[u] ^ 1; q.push(v); }",
      "\t\t\t\telse if (color[v] == color[u]) return false;",
      "\t\t\t}",
      "\t\t}",
      "\t\treturn true;",
      "\t}",
      "\tvoid DFS(const _Tp& root) {",
      "\t\tif (!hasNode(root)) return;",
      "\t\tstd::set<_Tp> visited;",
      "\t\tdfsUtil(root, visited, std::nullopt);",
      "\t}",
      "\tvoid BFS(const _Tp& root) {",
      "\t\tif (!hasNode(root)) return;",
      "\t\tstd::set<_Tp> visited;",
      "\t\tstd::queue<_Tp> q;",
      "\t\tvisited.insert(root);",
      "\t\tq.push(root);",
      "\t\twhile (!q.empty()) {",
      "\t\t\tauto node = q.front(); q.pop();",
      "\t\t\tstd::cout << node << \"\\n\"; // <== Do something",
      "\t\t\tfor (const auto& n : g[node]) {",
      "\t\t\t\tif (visited.find(n) != visited.end()) continue;",
      "\t\t\t\tvisited.insert(n);",
      "\t\t\t\tq.push(n);",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "};",
      "template <typename _Tp>",
      "class Segment_Tree {",
      "private:",
      "\tstd::vector<_Tp> Tree, arr, lazy;",
      "\tbool one_based;",
      "\tvoid lazyUpdate(long long node, long long l, long long r) {",
      "\t\tif (lazy[node] != 0) {",
      "\t\t\tTree[node] += (r - l + 1) * lazy[node]; // <== CHANGE FOR max: Tree[node] += lazy[node];",
      "\t\t\tif (l != r) {",
      "\t\t\t\tlazy[2 * node] += lazy[node];",
      "\t\t\t\tlazy[2 * node + 1] += lazy[node];",
      "\t\t\t}",
      "\t\t\tlazy[node] = 0;",
      "\t\t}",
      "\t}",
      "\tvoid build(long long node, long long l, long long r) {",
      "\t\tif (l == r) {",
      "\t\t\tTree[node] = arr[l];",
      "\t\t\treturn;",
      "\t\t}",
      "\t\tlong long mid = (l + r) / 2;",
      "\t\tbuild(2 * node, l, mid);",
      "\t\tbuild(2 * node + 1, mid + 1, r);",
      "\t\tTree[node] = Tree[2 * node] + Tree[2 * node + 1]; // <== CHANGE FOR max: max(Tree[2 * node], Tree[2 * node + 1])",
      "\t}",
      "\t_Tp queryUtil(long long node, long long l, long long r, long long start, long long end) {",
      "\t\tlazyUpdate(node, l, r);",
      "\t\tif (end < l || r < start) return 0; // <== CHANGE FOR max: LLONG_MIN",
      "\t\tif (start <= l && r <= end) return Tree[node];",
      "\t\tlong long mid = (l + r) / 2;",
      "\t\t_Tp left = queryUtil(2 * node, l, mid, start, end);",
      "\t\t_Tp right = queryUtil(2 * node + 1, mid + 1, r, start, end);",
      "\t\treturn left + right; // <== CHANGE FOR max: max(left, right)",
      "\t}",
      "\tvoid updateUtil(long long node, long long index, long long value, long long l, long long r) {",
      "\t\tlazyUpdate(node, l, r);",
      "\t\tif (l == r) {",
      "\t\t\tarr[index] += value;",
      "\t\t\tTree[node] += value;",
      "\t\t\treturn;",
      "\t\t}",
      "\t\tlong long mid = (l + r) / 2;",
      "\t\tif (index <= mid) updateUtil(2 * node, index, value, l, mid);",
      "\t\telse updateUtil(2 * node + 1, index, value, mid + 1, r);",
      "\t\tTree[node] = Tree[2 * node] + Tree[2 * node + 1]; // <== CHANGE FOR max: max(Tree[2 * node], Tree[2 * node + 1])",
      "\t}",
      "\tvoid rangeUpdateUtil(long long node, long long l, long long r, long long value, long long start, long long end) {",
      "\t\tlazyUpdate(node, l, r);",
      "\t\tif (r < start || end < l) return;",
      "\t\tif (start <= l && r <= end) {",
      "\t\t\tTree[node] += value * (r - l + 1); // <== CHANGE FOR max: Tree[node] += value",
      "\t\t\tif (l != r) {",
      "\t\t\t\tlazy[2 * node] += value;",
      "\t\t\t\tlazy[2 * node + 1] += value;",
      "\t\t\t}",
      "\t\t\treturn;",
      "\t\t}",
      "\t\tlong long mid = (l + r) / 2;",
      "\t\trangeUpdateUtil(2 * node, l, mid, value, start, end);",
      "\t\trangeUpdateUtil(2 * node + 1, mid + 1, r, value, start, end);",
      "\t\tTree[node] = Tree[2 * node] + Tree[2 * node + 1]; // <== CHANGE FOR max: max(Tree[2 * node], Tree[2 * node + 1])",
      "\t}",
      "public:",
      "\t_Tp query(long long start, long long end) {",
      "\t\tif (one_based) return queryUtil(1, 1, arr.size() - 1, start, end);",
      "\t\treturn queryUtil(1, 0, arr.size() - 1, start, end);",
      "\t}",
      "\tvoid update(long long index, long long value) {",
      "\t\tif (one_based) updateUtil(1, index, value, 1, arr.size() - 1);",
      "\t\telse updateUtil(1, index, value, 0, arr.size() - 1);",
      "\t}",
      "\tvoid rangeUpdate(long long start, long long end, long long value) {",
      "\t\tif (one_based) rangeUpdateUtil(1, 1, arr.size() - 1, value, start, end);",
      "\t\telse rangeUpdateUtil(1, 0, arr.size() - 1, value, start, end);",
      "\t}",
      "\tSegment_Tree(std::vector<_Tp> &a, bool is_one_based = false) {",
      "\t\tone_based = is_one_based;",
      "\t\tarr = is_one_based ? vector<_Tp>(a.size() + 1) : a;",
      "\t\tif (is_one_based) for (long long i = 1; i < arr.size(); i++) arr[i] = a[i - 1];",
      "\t\tTree.resize(4 * arr.size(), 0); // <== CHANGE FOR max: LLONG_MIN",
      "\t\tlazy.resize(4 * arr.size());",
      "\t\tif (one_based) build(1, 1, arr.size() - 1);",
      "\t\telse build(1, 0, arr.size() - 1);",
      "\t}",
      "};",
      "template <typename _Tp>",
      "class Fenwick_Tree {",
      "private:",
      "\tstd::vector<_Tp> Tree;",
      "public:",
      "\tvoid init() {",
      "\t\tfor (long long i = 1; i <= this->Tree.size(); i++) {",
      "\t\t\tlong long parent = i + (i & -i);",
      "\t\t\tif (parent <= this->Tree.size()) {",
      "\t\t\t\tthis->Tree[parent - 1] += this->Tree[i - 1];",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\t_Tp sum(long long l, long long r) {",
      "\t\t_Tp sum = 0;",
      "\t\twhile (r > 0) {",
      "\t\t\tsum += this->Tree[r - 1];",
      "\t\t\tr -= (r & -r);",
      "\t\t}",
      "\t\tl--;",
      "\t\twhile (l > 0) {",
      "\t\t\tsum -= this->Tree[l - 1];",
      "\t\t\tl -= (l & -l);",
      "\t\t}",
      "\t\treturn sum;",
      "\t}",
      "\tvoid update(long long index, _Tp difference) {",
      "\t\twhile (index <= this->Tree.size()) {",
      "\t\t\tthis->Tree[index - 1] += difference;",
      "\t\t\tindex += (index & -index);",
      "\t\t}",
      "\t}",
      "\tFenwick_Tree(const std::vector<_Tp> &array) {",
      "\t\tthis->Tree = array;",
      "\t\tthis->init();",
      "\t}",
      "};",
      "vector<long long> primes{};",
      "void genPrimes(long long lim = 2.53e6);",
      "int main(int argc, char const *argv[]) {",
      "\t#if !defined(DEBUG)",
      "\t\tios_base::sync_with_stdio(false);",
      "\t\tcin.tie(NULL);",
      "\t\tcout.tie(NULL);",
      "\t#endif",
      "\ttotal$1Solution();",
      "\treturn 0;",
      "}",
      "void caseSolution() {",
      "\tlong long n = 0, m = 0, k = 0, l = 0, sum = 0, t1 = 0, t2 = 0;",
      "\tstring s = \"\", t = \"\";",
      "\tcin >> ${2:n};",
      "\t$0",
      "}",
      "void totalSolution() {",
      "\tlong long T;",
      "\tcin >> T;",
      "\twhile (T-- > 0) caseSolution();",
      "}",
      "uint64_t custom_hash::splitmix64(uint64_t x) {",
      "\tx += 0x9e3779b97f4a7c15;",
      "\tx = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
      "\tx = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
      "\treturn x ^ (x >> 31);",
      "}",
      "size_t custom_hash::operator()(uint64_t x) const {",
      "\tstatic const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
      "\treturn splitmix64(x + FIXED_RANDOM);",
      "}",
      "void genPrimes(long long lim) {",
      "\tvector<bool> visited(lim, 0);",
      "\tfor (long long p = 2; p < lim; p++) {",
      "\t\tif (visited[p]) continue;",
      "\t\tfor (long long i = p * p; i < lim; i += p) visited[i] = 1;",
      "\t\tprimes.push_back(p);",
      "\t}",
      "}",
      "long long nCr(long long n, long long r) {",
      "\tif (r > n) return 0;",
      "\tif (r > n - r) r = n - r;",
      "\tunsigned long long result = 1;",
      "\tfor (int i = 0; i < r; ++i) {",
      "\t\tresult *= (n - i);",
      "\t\tresult /= (i + 1);",
      "\t}",
      "\treturn result;",
      "}",
    ],
    "description": "Basic C++ code structure"
  },
  "TestCase input and loop": {
    "prefix": "tci",
    "body": [
      "cin >> T;",
      "while (T-- > 0) {",
      "\tcin >> n;",
      "\tres = 0;",
      "\t$2",
      "\tlast:",
      "}"
    ],
    "description": "Testcase code"
  },
  "Array Input snippet": {
    "prefix": "arrin",
    "body": [
      "long long c = 0;",
      "while (c < ${2:n}) {",
      "\tcin >> ${3:nums}[c++];$4",
      "}",
      "$0"
    ],
    "description": "Array input"
  },
  "Include Header syntax": {
    "prefix": "inc",
    "body": [
      "#include <$1>"
    ],
    "description": "Quickly include header file."
  },
  "Shorthand for cout...endl": {
    "prefix": "cio",
    "body": [
      "std::cout << ${1:res} << \"\\n\";"
    ],
    "description": "Quickly use C++ standard output with new line."
  },
  "Shorthand for outputting Strings": {
    "prefix": "cis",
    "body": [
      "printf(\"%s\\n\", ${1:s}.c_str());"
    ],
    "description": "Quickly use C++ standard output with new line."
  }
}
